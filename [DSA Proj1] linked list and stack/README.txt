********************************************************************************************
	Class: Data Structure and Algorithms, KECE208
		   fall, 2020

	1st Project: List
	linked_list.c

	Name:박지혁 
	StudentID:2016160145
	E-mail:wlgur1023@naver.com
********************************************************************************************
==========================================================

RemoveFront(struct linked_list*)
 리스트의 첫 번째 노드를 제거하는 함수이다.
 리스트의 노드의 개수가 한 개인지, 두 개 이상인지의 여부에 따라 분기되어 작동하며
주 동작은 리스트의 첫 번째 노드를 메모리 해제하고 head 노드를 그 다음 노드로 업데이트 
하는 것이다.


RemoveRear(struct linked_list*)
 리스트의 마지막 노드를 제거하는 함수이다.
 역시 마찬가지로 노드의 개수가 한 개인지, 두 개 이상인지의 여부에 따라 분기되어 작동하며
노드의 개수가 한 개인 경우는 RemoveFront와 같은 동작을 하고, 노드의 개수가 두 개 이상인 
경우는 
마지막 노드를 메모리 해제 한 후 tail 노드를 마지막 노드에서 두번째 노드로 업데이트 한다.


 위의 RemoveFront 함수와 RemoveRear 함수는 linked_list.c 내에서 다른 함수들 내에 여러번 
참조되어 리스트의 요소를 제거하는 기능을 수행되었으며, 노드의 제거와 메모리 해제, head와
 tail 포인터의 업데이트와 같은 기능들을 함수로 묶어 프로그램의 가독성을 높이는 데 도움이 
되었다.

==========================================================

remove_list(struct linked_list*)
 리스트를 전부 삭제하는 함수이다.
 데이터의 타입이 링크드 리스트인지, 스택인지의 여부에 따라 분기되어 각각 RemoveFront와
RemoveRear를 통해 앞 쪽 부터 혹은 뒤 쪽 부터 노드를 삭제하였다. 
while문을 통해 리스트의 노드의 개수가 0이 될 때 까지 삭제를 반복하며, 
 매 삭제 과정에서 현재 삭제된 노드의 값을 출력한다.

리스트의 노드의 개수가 0이 되면 리스트의 head, tail 포인터를 우선적으로 메모리 해제 한 후
리스트 포인터를 메모리 해제 함으로서 확실하게 프로세스의 메모리 사용을 관리한다.

그 후 삭제된 노드의 개수를 출력하며 리스트가 완전히 삭제되었음을 알리고, 전역 변수
list_exist를 통해 리스트의 존재가 없음을 명시한다.

==========================================================

remove_node(struct linked_list*, int)
 파라미터로 전달 받은 int rm_node_value의 값을 찾아 리스트에서 제거한다.

for문을 다음과 같이 작성하여

for(del_Node = list->head; del_Node != NULL; del_Node = del_Node->next)	
	if(del_Node->value == rm_node_value) break;

보다 깔끔하게 search 로직을 구현하였으며 만약 del_Node 가 NULL에 도달한 경우
에러메세지를 출력할 수 있도록 하였다.

삭제할 del_Node가 리스트의 가장 앞, 가장 뒤, 중간인 경우로 분기하여 앞서 작성한
RemoveFront, RemoveRear 함수를 재사용 할 수 있도록 하였다.

만약 리스트의 노드 개수가 0이 되면 이는 리스트의 노드를 전부 삭제한 것을 의미하므로
리스트의 포인터들을 해제하여 리스트가 삭제될 수 있도록 하였다.


==========================================================

push_Stack(struct linked_list*, struct linked_node*)

스택은 LIFO 방식으로 노드가 삽입되는 방식이 리스트와 반대이기 때문에 앞서 구현되어
있던 insert_node 함수를 반대로 설계하여 보다 쉽게 구현할 수 있다.

리스트에 노드가 없는 경우, 노드가 한 개 있는 경우, 노드가 두 개 이상인 경우로 분기하여
리스트 포인터의 주소를 각각 새로운 노드와 연결 될 수 있도록 하였다.

에러처리는 제시된 pdf의 설명을 동일하게 따르도록 하였다.

==========================================================

pop_Stack(struct linked_list*, int)

파라미터로 입력받은 int number의 값 만큼 for문을 통해 RemoveRear함수를 반복하여
리스트의 마지막 노드를 반복적으로 제거한다.

만약 노드를 전부 제거하여 리스트의 노드 개수가 0이라면 이는 리스트의 제거를 의미하
므로, 리스트 포인터의 각 요소를 메모리 해제 한 후 리스트를 삭제한다. 그 후 전역변수
list_exist를 통해 리스트의 삭제를 명시한다.

에러처리는 제시된 pdf의 설명을 동일하게 따르도록 하였다.

***반복문에 사용된 for(; number; number--) 는 while(number--)와 동일한 동작을 의도
하도록 사용되었다.

==========================================================

search_node(struct linked_list*, int)

파라미터로 입력받은 int find_node_value의 값을 리스트로부터 찾는다.

이미 remove_node(struct linked_list*, int)에서 구현한 search 로직을 응용하여 작성하였다.

단, 노드의 순서(order)는 1부터 시작하는 것으로 가정하였다.

에러처리는 제시된 pdf의 설명을 동일하게 따르도록 하였다.

***반복문에 사용된 for(ptr = list->head; ptr != NULL; ptr = ptr->next, order++)는
반복문 내에서 order의 계산을 같이 처리하도록 하여 가독성을 높일 수 있도록 하기 위해
사용되었다.
==========================================================
