*********************************************
 Class: Data Structure and Algorithms
 Project 2: Binary Search Tree

 BST.c

 Name:		Park Ji Hyuk
 StudentID:	2016160145
 E-mail:	wlgur1023@naver.com

 **********************************************

1. treeNode createNode(char inputData)
char 형의 파러미터를 입력받는다.

만약, 입력데이터가 ASCII 코드의 소문자의 영역이 아니라면 에러메시지를 출력하고
NULL 포인터를 리턴한다.

treeNode 구조체 포인터 형의 메모리공간을 할당한다.
만약, 메모리 할당에 실패하면 에러메시지를 출력하고 NULL 포인터를 리턴한다.
이는 자주 사용되는 일반적인 메모리 할당 구문이다.

할당된 메모리의 각 요소들을 초기화 시킨 후 생성된 구조체 포인터 newNode를 리턴한다.


2. int insertNode(char inputData)
char 형의 파라미터를 입력받는다.

앞의 createNode로 생성된 구조체 포인터 주소를 받아올 변수 newNode를 생성하는 것 외에도,
for문 내부에서 반복적으로 쓸 변수인 existNode와 버퍼로 쓸 butNode를 생성한다.

입력받은 파라미터를 printf문으로 출력하여 화면 상에 나타낸다.

newNode = createNode() 를 통해 새롭게 생성된 구조체 포인터 주소를 newNode에 저장한다.
만약, 생성이 실패하면 노드의 생성이 실패했다는 에러메시지를 출력하고 0을 리턴한다.

만약, rootNode가 없다면 생성된 newNode를 rootNode로 만든 후, 생성이 성공적으로 되었다는 
메시지를 출력하고 0을 리턴한다.

rootNode가 존재한다면 바로 위의 if문에서 걸리지 않았을 것이므로 for문으로 오게 된다.
for문은 루트노드부터 리프에 닿을 때 까지, 존재하는 노드에 대해 반복적으로 수행된다.
만약, 입력파라미터와 현재 노드의 데이터가 중복된다면 에러메시지를 출력하고 반복문을 종료한다.
만약, 입력파라미터가 현재 노드의 데이터보다 작다면 현재 노드의 왼쪽 자식으로 이동한다.
만약, 입력파라미터가 현재 노드의 데이터보다 작다면 현재 노드의 오른쪽 자식으로 이동한다.
이때 flag변수로 선언된 foundLeft는 가장 마지막 이동이 왼쪽 자식으로의 이동인지,
오른쪽 자식으로의 이동인지를 체크한다.

반복문이 종료되면 버퍼노드에는 가장 마지막의 리프노드가 담겨있게 된다. 
따라서 새 노드의 부모노드를 이 버퍼노드로 지정하면 새로운 리프를 만들 수 있다.
마찬가지로 이 버퍼노드의 자식노드를 새 노드로 지정하여 doubly linked 될 수 있도록 한다.
이때 앞서 선언한 flag변수 foundLeft로 버퍼노드의 자식노드가 왼쪽 자식인지, 오른쪽 자식인지
확인할 수 있도록 한다.
입력이 잘 되었으므로 생성이 성공적으로 이루어졌다는 메시지를 출력하고 0을 리턴한다.


3. isNodeExist
char 형의 파라미터를 입려받는다.

현재 노드를 탐색하기 위해 변수 existNode를 선언한다.

만약, rootNode가 없다면 트리가 비어있다는 에러메시지를 출력하고 0을 리턴한다.

위의 조건문에 걸리지 않았다면 for문으로 이동하여 루트노드부터 존재하는 노드들을
탐색하게 된다.
만약, 입력파라미터와 현재 노드의 데이터가 일치한다면 1을 리턴한다.
만약, 입력파라미터가 현재 노드의 데이터보다 작다면 현재 노드의 왼쪽 자식으로 이동한다.
만약, 입력파라미터가 현재 노드의 데이터보다 작다면 현재 노드의 오른쪽 자식으로 이동한다.

for문이 중간에 1을 리턴하지 않고 종료되었다면 이는 트리의 리프노드에 도달하였다는 뜻이므로
입력파라미터가 트리에 존재하지 않는다는 에러메시지를 출력하고 0을 리턴한다.


4. treeNode findPosition(char inputData, treeNode node)
이 함수는 재귀함수로 구현되었다.

char 형과 treeNode 형의 파라미터를 입력받는다.

종결 조건으로 inputData와 현재 노드의 데이터가 일치한다는지 확인한다.

만약, inputData와 현재 노드의 데이터가 일치한다면 현재 노드를 리턴한다.

만약, inputData와 현재 노드의 데이터가 일치하지 않고, 현재 노드가 리프노드라면,
이는 트리의 탐색 후 나타난 현재의 노드가, 리프노드 중 inputData와 가장 가까운 노드임을
의마하므로 현재의 리프노드를 리턴한다.

재귀 조건으로 inputData와 현재 노드의 데이터의 대소를 비교한다.

만약, inputData가 현재 노드의 데이터보다 작다면 현재 노드의 왼쪽 자식으로 파라미터를
이동하여 함수를 재귀호출한다.
이때, 호출된 재귀함수의 리턴으로 얻어진 서브트리에서의 inputData와 특정 노드간의 최소
거리가 현재 노드와의 최소거리보다 크다면 이는 inputData와 가장 가까운 값이 현재 노드라는
의미이므로 현재 노드를 리턴한다.

만약, inputData가 현재 노드의 데이터보다 크다면 현재 노드의 오른쪽 자식으로 파라미터를
이동하여 함수를 재귀호출한다.
이때, 호출된 재귀함수의 리턴으로 얻어진 서브트리에서의 inputData와 특정 노드간의 최소
거리가 현재 노드와의 최소거리보다 크다면 이는 inputData와 가장 가까운 값이 현재 노드라는
의미이므로 현재 노드를 리턴한다.

이를 통해 inputData와 트리의 노드 데이터가 정확히 match되지 않더라도 가장 가까운 노드를
찾을 수 있도록 하였다.

이 과정에서 거리비교를 편하게 하기 위하여 삼항연산자를 이용해 절댓값을 갖는 거리를 선언
하였다.


5. int findDepth(char inputData)
char 형으로 파라미터를 입력받는다.

에러조건으로 노드가 존재하지 않으면 0을 리턴한다.

트리의 depth는 -1을 기본값으로 갖고 시작하며, 깊이가 깊어질 수록 +1씩 증가된다.

앞의 함수들과 비슷하게 for문을 통해 리프노드를 만날 때 까지 inputData를 탐색하며
이 과정에서 반복문을 돌 때마다 depth를 +1씩 증가시킨다.

for문이 종료된 후에는 depth를 리턴한다.


6. treeNode findMin(treeNode node)
treeNode 형으로 파라미터를 입력받는다. project2 함수에서는 이 함수의 입력 인자로 
rootNode를 넘긴다.

에러조건으로 입력받은 파라미터가 NULL이라면 이는 rootNode가 비어있다는 뜻이므로
트리가 비어있다는 에러메시지를 출력하고 NULL을 리턴한다.

앞의 함수들과 비슷하게 for문을 이용하지만, 이번에는 계속 왼쪽 노드로만 이동해간다.

리프노드를 만나면 for문은 종료되고 이때 마지막으로 만난 리프노드가 트리에서 가장 
작은 노드이다. 이는 BST의 성질에 기인한다.

현재 노드의 데이터를 출력하고 현재노드를 리턴한다.


7. int findNode(char inputData) 
char 형으로 파라미터를 입력받는다.

에러조건으로 노드가 존재하지 않으면 0을 리턴한다.

에러조건을 무사히 통과하면, 앞서 만든 findPosition함수를 통해 inputData의 위치를 
검색해낸다.

이후 해당 위치의 요소들을 출력한다. 요소들을 출력시, 요소의 값이 비워져 있는 경우를
대비하여 조건문으로 출력문들을 분기시킨다.

출력이 끝나면 1을 리턴한다.


8. int findHeight(void) 
파라미터를 입력받지 않는다.

에러조건으로 루트노드가 NULL인 경우, 트리가 비워져있음을 에러메시지로 출력하고
-1을 리턴한다.

에러조건을 무사히 통과하면, a 부터 z 까지 모든 가능한 입력에 대해 트리에 존재하는
노드를 순회하며 트리에 존재하는 알파벳을 찾아내고 해당 알파벳이 입력으로 있는 노드의
높이를 findDepth를 통해 구한다. 만약 높이가 더 높은 노드를 찾아낸다면 높이를 갱신한다.

리프노드를 만나 for문이 종료되면 갱신된 최대 높이를 출력하고 해당 높이를 리턴한다.
